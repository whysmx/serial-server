# Serial-Server 串口服务器设计文档

## 1. 概述

Serial-Server 是一个**串口服务器**工具，支持将串口设备映射为 TCP 服务端口。

**主要功能：**
- 多个串口设备映射到不同 TCP 端口
- 支持 UTF8、GB2312、HEX 三种显示格式
- 支持单客户端（踢旧连接）和多客户端模式
- 交互式配置向导
- 终端图形界面（TUI）

## 2. 配置文件

配置文件 `config.ini` 采用 INI 格式。

### 2.1 配置示例

```ini
# 串口设备 A - 映射到 9600 端口
[device_1]
listen_port = 9600
serial_port = /dev/cu.usbserial-1
baud_rate = 115200
display_format = UTF8
max_clients = 1

# 串口设备 B - HEX 格式显示
[device_2]
listen_port = 9601
serial_port = /dev/cu.usbserial-2
baud_rate = 9600
display_format = HEX
max_clients = 0
```

### 2.2 字段说明

| 字段 | 必填 | 默认值 | 说明 |
|------|------|--------|------|
| `listen_port` | 是 | - | TCP 监听端口 |
| `serial_port` | 是 | - | 串口设备路径，如 `COM3` 或 `/dev/ttyUSB0` |
| `baud_rate` | 否 | 115200 | 波特率：300/1200/2400/4800/9600/19200/38400/57600/115200 |
| `data_bits` | 否 | 8 | 数据位：5/6/7/8 |
| `stop_bits` | 否 | 1 | 停止位：1/2 |
| `parity` | 否 | N | 校验位：N(无)/O(奇校验)/E(偶校验) |
| `display_format` | 否 | UTF8 | 显示格式：HEX / GB2312 / UTF8 |

## 3. 数据流转

```
TCP 客户端                    串口服务器                    串口设备
    │                            │                           │
    │  [:9600]                   │      /dev/ttyUSB0         │
    │ ◄───────────────────────── │ ◄──────────────────────── │
    │       TCP 数据             │      串口数据             │
    │                           │                           │
    │  实时转发                  │     实时转发              │
    │ ─────────────────────────►│─────────────────────────► │
    │                           │                           │
```

**数据流转：**
1. TCP 客户端连接到 9600
2. TCP → 串口：客户端发送的数据通过队列实时写入串口
3. 串口 → TCP：串口响应数据通过请求-响应匹配返回给对应客户端
4. 支持多客户端（`max_clients = 0`）或多选一（`max_clients = 1`）

## 4. 架构

```
                    ┌─────────────────────┐
                    │     config.ini      │
                    └──────────┬──────────┘
                               │
         ┌─────────────────────┼─────────────────────┐
         │                     │                     │
         ▼                     ▼                     ▼
  ┌─────────────┐      ┌─────────────┐      ┌─────────────┐
  │  device_1   │      │  device_2   │      │  device_3   │
  │ 9600→USB0   │      │ 9601→USB1   │      │ 9602→USB2   │
  └─────────────┘      └─────────────┘      └─────────────┘
         │                     │                     │
         └─────────────────────┼─────────────────────┘
                               │
                    ┌──────────┴──────────┐
                    │     TUI 终端界面     │
                    │  (顶部导航 + 数据区)  │
                    └─────────────────────┘
```

## 5. 命令行参数

| 命令 | 说明 |
|------|------|
| `./serial-server` | 有配置直接启动，无配置进入向导 |
| `./serial-server --wizard` | 强制进入交互式配置向导 |
| `./serial-server --list` | 列出可用串口设备 |
| `./serial-server --check` | 验证配置文件 |
| `./serial-server --log file.log` | 输出日志到文件 |
| `./serial-server --version` | 显示版本信息 |

## 6. 终端界面

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ [1] :9600 cu.usbserial-1 115200 UTF8 ↑2↓1   [2] :9601 cu.usbserial-2 9600 HEX ↑1↓0   [M]菜单  │
├─────────────────────────────────────────────────────────────────────────────┤
│ [12:34:56] TX: Hello                                                      │
│ [12:34:57] RX: 你好世界                                                    │
│ [12:34:58] TX: 41 42 43                                                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**顶部导航栏：**
- `[1] [2]` → 按数字键或 Tab 切换焦点
- 显示格式：`[序号] :端口 串口 波特率 格式 发送数↑接收数↓`
- `[M]菜单` → 按 `M` 键打开菜单

**快捷键：**
- `1-9` / `Tab` - 切换监听器焦点
- `M` - 打开菜单
- `C` - 清屏
- `Ctrl+C` / `Ctrl+Q` - 退出

## 7. 依赖

```
go >= 1.20
github.com/tarm/serial
gopkg.in/ini.v1
github.com/gdamore/tcell/v2
github.com/mattn/go-runewidth
```

## 8. 项目结构

```
serial-server/
├── main.go           # 程序入口
├── config/           # 配置加载/保存
├── listener/         # 串口监听器
│   ├── queue.go      # 多客户端请求队列与缓存
│   └── listener.go   # 监听器核心逻辑
├── serial/           # 串口操作封装
├── tui/              # 终端界面
└── wizard/           # 交互式配置向导
```

## 9. 多客户端队列机制

当 `max_clients = 0` 时，启用多客户端队列模式，支持多个 TCP 客户端同时连接。

### 9.1 请求队列（WriteQueue）

**核心设计：FIFO 串行写入**

```
客户端1 ──┐
客户端2 ──┼─► WriteQueue ─► 串口设备
客户端3 ──┘     (FIFO)
```

- 多个客户端的写入请求按 FIFO 顺序排队
- 同一时间只有一个请求写入串口
- 避免并发写入导致数据混乱

### 9.2 响应缓存（RequestCache）

**5 秒 TTL 自动过期**

```
请求 A (hash=0x123) ──► 串口 ──► 响应 X
                     ↓
                缓存 [0x123: X]
                     ↓
请求 A (相同数据) ────► 直接返回缓存响应 X
```

- 相同数据的请求自动命中缓存，无需重复写入串口
- TTL 5 秒，避免旧数据占用内存
- 适合查询类命令（如读取传感器状态）

### 9.3 请求-响应匹配

**严格 FIFO 顺序匹配**

```
时间线：
T1: 客户端1发送 CMD_A ──► 队列第1位 ──► 写入串口
T2: 客户端2发送 CMD_B ──► 队列第2位 (等待)
T3: 串口响应 RESP_A ──► 匹配队列第1位 ──► 返回客户端1
T4: CMD_B 开始写入串口
```

- 串口响应严格按照 FIFO 顺序匹配到对应的请求
- 第一个请求的响应返回后，才处理下一个请求

## 10. 并发安全设计

### 10.1 单一完成者模型（Single Finisher）

**问题：** 多个 goroutine 可能同时操作同一个响应通道：
- `sendToSerial` 写入失败时尝试关闭
- `OnSerialData` 收到响应时尝试关闭
- `CleanupExpired` 超时时尝试关闭

**解决方案：** 使用 `atomic.Bool` 确保通道只关闭一次

```go
type PendingRequest struct {
    ResponseCh chan []byte
    done       atomic.Bool  // 完成标记
}

// 只会执行一次
func (r *PendingRequest) finishWithResponse(data []byte) {
    if r.done.Swap(true) {  // 原子操作，设置为 true 并返回旧值
        return  // 如果已经是 true，说明已完成，直接返回
    }
    r.ResponseCh <- data
    close(r.ResponseCh)
}
```

**保证：**
- ✅ 不会 double close（导致 panic）
- ✅ 不会 send on closed channel
- ✅ 不会吞掉缓冲数据

### 10.2 锁策略

| 场景 | 锁 | 说明 |
|------|-----|------|
| 队列操作（添加/移除请求） | `mu.Mutex` | 保护 `pending` 队列和 `clientIndex` |
| 清理定时器停止 | `sync.Once` | 确保 `stopCleanup` channel 只关闭一次 |
| 请求完成标记 | `atomic.Bool` | 无锁快速检查，避免通道操作竞争 |

**关键：先移除，后完成**

```go
// sendToSerial 失败处理
q.mu.Lock()
q.pending = q.pending[1:]  // 先从队列移除
q.mu.Unlock()

req.finishNoResponse()     // 后完成（无锁操作）
```

移除操作（持锁）和完成操作（无锁）分离，避免持锁时间过长。

## 11. 超时与错误处理

### 11.1 请求超时（3 秒）

```
T0: 请求写入串口
T3: 未收到响应 ──► CleanupExpired 标记为超时
                 - 关闭响应通道
                 - 从队列移除
                 - 触发下一个请求
```

### 11.2 写入失败处理

```
写入串口失败 ──► 立即处理：
                 - 从队列移除
                 - 关闭响应通道（通知客户端失败）
                 - 触发下一个请求
```

### 11.3 资源清理

- **监听器停止**：停止清理定时器 goroutine
- **启动失败**：清理已启动的监听器，避免端口占用
- **定时器泄漏防护**：`sync.Once` 确保只停止一次

## 12. 与原版 bridge 的区别

| 项目 | 目录 | 功能 |
|------|------|------|
| **bridge** | `~/code/bridge/` | TCP↔TCP 桥接器，原有功能 |
| **serial-server** | `~/code/serial-server/` | TCP↔Serial 串口服务器 |

两个项目相互独立：
- `bridge` - 简单轻量，只做 TCP 端口之间的数据透传
- `serial-server` - 功能丰富，支持串口设备、图形界面、多种显示格式
